WHITESPACE = _{ " " | "\t" | NEWLINE }

// Comments use {..} syntax with non-greedy matching
COMMENT = _{ "{" ~ (!"}" ~ ANY)* ~ "}" }

program = { SOI ~ begin ~ statement* ~ end ~ EOI }
statement   = _{ 
  var_decl 
  | daini
  | write
  | read
  | assignment 
  | function
  | loop
  | ploop
  | procedure
  | procedure_call
  | if_statement }

/// BEGIN and END
begin = { "BEGIN" ~ semicolon }
end = { "END" ~ semicolon }

/// WRITE
write = { "WRITE" ~ unit ~ expr+ ~ semicolon }
read = { "READ" ~ unit ~ variable_identifier ~ semicolon }

/// VARIABLE
var_decl = { "VARIABLE" ~ type ~ variable_name ~ semicolon }

/// Keywords - define all reserved words
keyword = { "BEGIN" | "END" | "WRITE" | "READ" | "VARIABLE" | "PROCEDURE" | "ENDPROCEDURE" | "EXP" | "IF" | "ELSEIF" | "ELSE" | "ENDIF" | "TRUE" | "FALSE" | "DAINI" | "LENGTH" | "SIN" | "rosy_universe" | "rosy_world" | "rosy_size" | "rosy_rank" }

/// [ IF / ELSEIF / ELSE / ENDIF ]
if_statement = { if_clause ~ elseif_clause* ~ else_clause? ~ endif }
if_clause = { "IF" ~ expr ~ semicolon ~ statement* }
elseif_clause = { "ELSEIF" ~ expr ~ semicolon ~ statement* }
else_clause = { "ELSE" ~ semicolon ~ statement* }
endif = { "ENDIF" ~ semicolon }

/// [ PROCEDURES / FUNCTIONS ]
  ///
  /// [ PROCEDURES ]
  /// Container
  procedure = { start_procedure ~ statement* ~ end_procedure }
  /// Calling - ensure the name is not a keyword
  procedure_call = { procedure_name ~ expr* ~ semicolon }
  /// PROCEDURE
  start_procedure = { "PROCEDURE" ~ procedure_name ~ procedure_argument_name_and_type* ~ semicolon }
  procedure_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  procedure_argument_name_and_type = { procedure_argument_name ~ type }
  procedure_argument_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  /// ENDPROCEDURE
  end_procedure = { "ENDPROCEDURE" ~ semicolon }
  ///
  /// [ FUNCTIONS ]
  /// Container
  function = { start_function ~ statement* ~ end_function }
  /// Calling - ensure the name is not a keyword
  function_call = { function_name ~ "(" ~ expr ~ ("," ~ expr)* ~ ")"  }
  /// FUNCTION
  start_function = { "FUNCTION" ~ type ~ function_name ~ function_argument_name_and_type+ ~ semicolon }
  function_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  function_argument_name_and_type = _{ function_argument_name ~ type }
  function_argument_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  /// ENDFUNCTION
  end_function = { "ENDFUNCTION" ~ semicolon }

/// [ LOOPS / WHILES ]
  ///
  /// [ LOOP ]
  loop = { start_loop ~ statement+ ~ end_loop }
  start_loop = { "LOOP" ~ variable_name ~ expr ~ expr ~ expr? ~ semicolon }
  end_loop = { "ENDLOOP" ~ semicolon }
  /// [ PLOOP ]
  ploop = { start_ploop ~ statement+ ~ end_ploop }
  start_ploop = { "PLOOP" ~ variable_name ~ expr ~ expr ~ semicolon }
  end_ploop = { "ENDPLOOP" ~ unit? ~ variable_identifier ~ semicolon }

/// [ INTRINSIC FUNCTIONS ]
  builtin_function = _{ cm | st | lo | da | length | sin }
  /// CM
  cm = { "CM(" ~ expr ~ ")" }
  /// ST - String conversion
  st = { "ST(" ~ expr ~ ")" }
  /// LO - Logical conversion
  lo = { "LO(" ~ expr ~ ")" }
  /// DA - Create DA identity vector
  da = { "DA" ~ "(" ~ expr ~ ")" }
  /// LENGTH - Get memory size
  length = { "LENGTH(" ~ expr ~ ")" }
  /// SIN - Compute sine
  sin = { "SIN(" ~ expr ~ ")" }

/// [ INTRINSIC PROCEDURES ]
  /// [ DA ]
  daini = { "DAINI" ~ expr ~ expr ~ semicolon }
/// [ INTRINSIC TYPES ]
  type = { "(" ~ inner_type ~ expr* ~ ")"}
  inner_type = {
    "RE" |
    "LO" |
    "VE" |
    "CM" |
    "ST" |
    "DA" |
    "CD" }

/// Assignment
assignment  = { variable_identifier ~ ":=" ~ expr ~ semicolon }

// Expression parsing using Pratt parser
expr = { term ~ (infix_op ~ term)* }
term = _{ 
    not_expr |
    builtin_function | 
    function_call |
    boolean |
    number | 
    string |
    variable_identifier |
    "(" ~ expr ~ ")" }

// Boolean literals
boolean = { "TRUE" | "FALSE" }

// NOT expression (prefix unary operator) - ROSY extension
// Use `!` directly adjacent to operand
not_expr = { "!" ~ (boolean | variable_identifier | "(" ~ expr ~ ")") }

// Infix operators
// Note: lte/gte must come before lt/gt to avoid `<=` being parsed as `<` then `=`
// We support both COSY syntax (= and #) and modern syntax (== and <>/!=)
infix_op    = _{ extract | mult | div | add | sub | concat | eq | neq | lte | gte | lt | gt }
extract     = { "|" }
add         = { "+" }
sub         = { "-" }
mult        = { "*" }
div         = { "/" }
concat      = { "&" }
eq          = { "==" | "=" }
neq         = { "<>" | "!=" | "#" }
lt          = { "<" }
gt          = { ">" }
lte         = { "<=" }
gte         = { ">=" }

variable_identifier = { variable_name ~ variable_indexing? }
variable_indexing = { "[" ~ expr ~ ("," ~ expr)* ~ "]" }
variable_name  = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
number      = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
unit        = @{ ASCII_DIGIT+ }
constant    = @{ ASCII_DIGIT+ }
string      = { new_string | old_string }
new_string  = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
old_string  = @{ "\'" ~ (!"\'" ~ ANY)* ~ "\'" }
semicolon   = { ";" }