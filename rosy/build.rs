use std::fs;
use std::path::{Path, PathBuf};
use std::io::Write;

fn main() {
    // Re-run if rosy_lib changes
    println!("cargo:rerun-if-changed=src/rosy_lib");
    
    // Generate the embedded files at compile time
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_rosy_lib.rs");
    let mut f = fs::File::create(&dest_path).unwrap();
    
    writeln!(f, "// Auto-generated by build.rs - do not edit manually!").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "pub struct EmbeddedFile {{").unwrap();
    writeln!(f, "    pub path: &'static str,").unwrap();
    writeln!(f, "    pub content: &'static str,").unwrap();
    writeln!(f, "}}").unwrap();
    writeln!(f, "").unwrap();
    writeln!(f, "pub const ROSY_LIB_FILES: &[EmbeddedFile] = &[").unwrap();
    
    // Walk the rosy_lib directory
    let lib_path = PathBuf::from("src/rosy_lib");
    let files = collect_files(&lib_path, &lib_path);
    
    let file_count = files.len();
    
    for file in files {
        let full_path = lib_path.join(&file);
        writeln!(f, "    EmbeddedFile {{").unwrap();
        writeln!(f, "        path: r#\"{}\"#,", file.display()).unwrap();
        writeln!(f, "        content: include_str!(r#\"{}\"#),", 
            full_path.canonicalize().unwrap().display()).unwrap();
        writeln!(f, "    }},").unwrap();
    }
    
    writeln!(f, "];").unwrap();
    
    println!("cargo:warning=Embedded {} rosy_lib files", file_count);
}

fn collect_files(root: &Path, current: &Path) -> Vec<PathBuf> {
    let mut files = Vec::new();
    
    if let Ok(entries) = fs::read_dir(current) {
        for entry in entries.flatten() {
            let path = entry.path();
            
            // Skip target directory
            if path.file_name().map_or(false, |n| n == "target") {
                continue;
            }
            
            if path.is_dir() {
                files.extend(collect_files(root, &path));
            } else if path.is_file() {
                // Include .rs, .rosy, and .fox files
                if let Some(ext) = path.extension() {
                    if ext == "rs" || ext == "rosy" || ext == "fox" {
                        if let Ok(relative) = path.strip_prefix(root) {
                            files.push(relative.to_path_buf());
                        }
                    }
                }
            }
        }
    }
    
    files.sort();
    files
}
