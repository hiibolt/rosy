WHITESPACE = _{ " " | "\t" | NEWLINE }

// Comments use {..} syntax with non-greedy matching
COMMENT = _{ "{" ~ (!"}" ~ ANY)* ~ "}" }

program = { SOI ~ begin ~ statement* ~ end ~ EOI }
statement   = _{ 
  var_decl 
  | write
  | read
  | assignment 
  | function
  | loop
  | procedure
  | procedure_call
  | if_statement }

/// BEGIN and END
begin = { "BEGIN" ~ semicolon }
end = { "END" ~ semicolon }

/// WRITE
write = { "WRITE" ~ unit ~ expr+ ~ semicolon }
read = { "READ" ~ unit ~ identifier ~ semicolon }

/// VARIABLE
var_decl = { "VARIABLE" ~ type ~ variable_name ~ semicolon }
variable_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }

/// Keywords - define all reserved words
keyword = { "BEGIN" | "END" | "WRITE" | "READ" | "VARIABLE" | "PROCEDURE" | "ENDPROCEDURE" | "EXP" | "IF" | "ELSEIF" | "ELSE" | "ENDIF" | "TRUE" | "FALSE" }

/// [ IF / ELSEIF / ELSE / ENDIF ]
if_statement = { if_clause ~ elseif_clause* ~ else_clause? ~ endif }
if_clause = { "IF" ~ expr ~ semicolon ~ statement* }
elseif_clause = { "ELSEIF" ~ expr ~ semicolon ~ statement* }
else_clause = { "ELSE" ~ semicolon ~ statement* }
endif = { "ENDIF" ~ semicolon }

/// [ PROCEDURES / FUNCTIONS ]
  ///
  /// [ PROCEDURES ]
  /// Container
  procedure = { start_procedure ~ statement* ~ end_procedure }
  /// Calling - ensure the name is not a keyword
  procedure_call = { procedure_name ~ expr* ~ semicolon }
  /// PROCEDURE
  start_procedure = { "PROCEDURE" ~ procedure_name ~ procedure_argument_name_and_type* ~ semicolon }
  procedure_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  procedure_argument_name_and_type = { procedure_argument_name ~ type }
  procedure_argument_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  /// ENDPROCEDURE
  end_procedure = { "ENDPROCEDURE" ~ semicolon }
  ///
  /// [ FUNCTIONS ]
  /// Container
  function = { start_function ~ statement* ~ end_function }
  /// Calling - ensure the name is not a keyword
  function_call = { function_name ~ "(" ~ expr ~ ("," ~ expr)* ~ ")"  }
  /// FUNCTION
  start_function = { "FUNCTION" ~ type ~ function_name ~ function_argument_name_and_type+ ~ semicolon }
  function_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  function_argument_name_and_type = _{ function_argument_name ~ type }
  function_argument_name = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
  /// ENDFUNCTION
  end_function = { "ENDFUNCTION" ~ semicolon }

/// [ LOOPS / WHILES ]
  ///
  /// [ LOOPS ]
  loop = { start_loop ~ statement+ ~ end_loop }
  start_loop = { "LOOP" ~ identifier ~ expr ~ expr ~ expr? ~ semicolon }
  end_loop = { "ENDLOOP" ~ semicolon }

/// [ INTRINSIC FUNCTIONS ]
  builtin_function = _{ exp | cm | st }
  /// EXP
  exp = { "EXP(" ~ expr ~ ")" }
  /// CM
  cm = { "CM(" ~ expr ~ ")" }
  /// ST - String conversion
  st = { "ST(" ~ expr ~ ")" }
/// [ INTRINSIC TYPES ]
  type = { "(" ~ inner_type ~ expr* ~ ")"}
  inner_type = {
    "RE" |
    "LO" |
    "VE" |
    "CM" |
    "ST" }

/// Assignment
assignment  = { (indexed_identifier | identifier) ~ ":=" ~ expr ~ semicolon }

// Expression parsing using Pratt parser
expr = { term ~ (infix_op ~ term)* }
term = _{ 
    indexed_identifier |
    builtin_function | 
    function_call |
    boolean |
    number | 
    string |
    identifier |
    "(" ~ expr ~ ")" }

// Boolean literals
boolean = { "TRUE" | "FALSE" }

// Infix operators
infix_op    = _{ extract | add | concat }
extract     = { "|" }
add         = { "+" }
concat      = { "&" }

indexed_identifier =   { identifier ~ "[" ~ expr ~ ("," ~ expr)* ~ "]" }
identifier  = @{ !keyword ~ (ASCII_ALPHANUMERIC | "_")+ }
number      = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
unit        = @{ ASCII_DIGIT+ }
string      = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
semicolon   = { ";" }